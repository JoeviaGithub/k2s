{
  "name": "elements",
  "version": "6.6.0",
  "kurentoVersion": "^6.1.0",
  "imports": [
    {
      "name": "core",
      "version": "^6.1.0",
      "mavenVersion": "[6.1.0,7.0.0-SNAPSHOT)",
      "npmVersion": ">=6.1.0 <7.0.0"
    }
  ],
  "code": {
    "kmd": {
      "java": {
        "mavenGroupId": "org.kurento",
        "mavenArtifactId": "kms-api-elements",
        "mavenVersion": "6.6.0"
      }
    },
    "api": {
      "java": {
        "packageName": "org.kurento.client",
        "mavenGroupId": "org.kurento",
        "mavenArtifactId": "kurento-client",
        "mavenVersion": "6.6.0"
      },
      "js": {
        "nodeName": "kurento-client-elements",
        "npmDescription": "Elements implementations for kurento media server",
        "npmGit": "Kurento/kurento-client-elements-js",
        "npmVersion": "6.6.0"
      }
    },
    "implementation": {
      "cppNamespace": "kurento",
      "lib": "libkmselements"
    }
  },
  "remoteClasses": [
    {
      "name": "DispatcherOneToMany",
      "doc": "A :rom:cls:`Hub` that sends a given source to all the connected sinks",
      "extends": "Hub",
      "constructor": {
        "params": [
          {
            "name": "mediaPipeline",
            "doc": "the :rom:cls:`MediaPipeline` to which the dispatcher belongs",
            "type": "MediaPipeline"
          }
        ],
        "doc": "Create a :rom:cls:`DispatcherOneToMany` belonging to the given pipeline."
      },
      "methods": [
        {
          "params": [
            {
              "name": "source",
              "doc": "source to be broadcasted",
              "type": "HubPort"
            }
          ],
          "name": "setSource",
          "doc": "Sets the source port that will be connected to the sinks of every :rom:cls:`HubPort` of the dispatcher"
        },
        {
          "params": [],
          "name": "removeSource",
          "doc": "Remove the source port and stop the media pipeline."
        }
      ]
    },
    {
      "name": "WebRtcEndpoint",
      "doc": "<p>\n      Control interface for Kurento WebRTC endpoint.\n      </p>\n      <p>\n      This endpoint is one side of a peer-to-peer WebRTC communication, being the other peer a WebRTC capable browser -using the RTCPeerConnection API-, a native WebRTC app or even another Kurento Media Server.\n      </p>\n      <p>\n      In order to establish a WebRTC communication, peers engage in an SDP negotiation process, where one of the peers (the offerer) sends an offer, while the other peer (the offeree) responds with an answer. This endpoint can function in both situations\n      <ul>\n        <li>\n          As offerer: The negotiation process is initiated by the media server\n          <ul style='list-style-type:circle'>\n            <li>KMS generates the SDP offer through the <code>generateOffer</code> method. This <i>offer</i> must then be sent to the remote peer (the offeree) through the signaling channel, for processing.</li>\n            <li>The remote peer process the <i>offer</i>, and generates an <i>answer</i> to this <i>offer</i>. The <i>answer</i> is sent back to the media server.</li>\n            <li>Upon receiving the <i>answer</i>, the endpoint must invoke the <code>processAnswer</code> method.</li>\n          </ul>\n        </li>\n        <li>\n          As offeree: The negotiation process is initiated by the remote peer\n          <ul>\n            <li>The remote peer, acting as offerer, generates an SDP <i>offer</i> and sends it to the WebRTC endpoint in Kurento.</li>\n            <li>The endpoint will process the <i>offer</i> invoking the <code>processOffer</code> method. The result of this method will be a string, containing an SDP <i>answer</i>.</li>\n            <li>The SDP <i>answer</i> must be sent back to the offerer, so it can be processed.</li>\n          </ul>\n        </li>\n      </ul>\n      </p>\n      <p>\n      SDPs are sent without ICE candidates, following the Trickle ICE optimization. Once the SDP negotiation is completed, both peers proceed with the ICE discovery process, intended to set up a bidirectional media connection. During this process, each peer\n      <ul>\n        <li>Discovers ICE candidates for itself, containing pairs of IPs and ports.</li>\n        <li>ICE candidates are sent via the signaling channel as they are discovered, to the remote peer for probing.</li>\n        <li>ICE connectivity checks are run as soon as the new candidate description, from the remote peer, is available.</li>\n      </ul>\n      Once a suitable pair of candidates (one for each peer) is discovered, the media session can start. The harvesting process in Kurento, begins with the invocation of the <code>gatherCandidates</code> method. Since the whole Trickle ICE purpose is to speed-up connectivity, candidates are generated asynchronously. Therefore, in order to capture the candidates, the user must subscribe to the event <code>IceCandidateFound</code>. It is important that the event listener is bound before invoking <code>gatherCandidates</code>, otherwise a suitable candidate might be lost, and connection might not be established.\n      </p>\n      <p>\n      It's important to keep in mind that WebRTC connection is an asynchronous process, when designing interactions between different MediaElements. For example, it would be pointless to start recording before media is flowing. In order to be notified of state changes, the application can subscribe to events generated by the WebRtcEndpoint. Following is a full list of events generated by WebRtcEndpoint:\n      <ul>\n        <li>\n          <code>IceComponentStateChange</code>: This event informs only about changes in the ICE connection state. Possible values are:\n          <ul style='list-style-type:circle'>\n            <li><code>DISCONNECTED</code>: No activity scheduled</li>\n            <li><code>GATHERING</code>: Gathering local candidates</li>\n            <li><code>CONNECTING</code>: Establishing connectivity</li>\n            <li><code>CONNECTED</code>: At least one working candidate pair</li>\n            <li><code>READY</code>: ICE concluded, candidate pair selection is now final</li>\n            <li><code>FAILED</code>: Connectivity checks have been completed, but media connection was not established</li>\n          </ul>\n          The transitions between states are covered in RFC5245.\n          It could be said that it's network-only, as it only takes into account the state of the network connection, ignoring other higher level stuff, like DTLS handshake, RTCP flow, etc.  This implies that, while the component state is <code>CONNECTED</code>, there might be no media flowing between the peers. This makes this event useful only to receive low-level information about the connection between peers. Even more, while other events might leave a graceful period of time before firing, this event fires immediately after the state change is detected.\n        </li>\n        <li>\n          <code>IceCandidateFound</code>: Raised when a new candidate is discovered. ICE candidates must be sent to the remote peer of the connection. Failing to do so for some or all of the candidates might render the connection unusable.\n        </li>\n        <li>\n          <code>IceGatheringDone</code>: Raised when the ICE harvesting process is completed. This means that all candidates have already been discovered.\n        </li>\n        <li>\n          <code>NewCandidatePairSelected</code>: Raised when a new ICE candidate pair gets selected. The pair contains both local and remote candidates being used for a component. This event can be raised during a media session, if a new pair of candidates with higher priority in the link are found.\n        </li>\n        <li>\n          <code>DataChannelOpen</code>: Raised when a data channel is open.\n        </li>\n        <li>\n          <code>DataChannelClose</code>: Raised when a data channel is closed.\n        </li>\n      </ul>\n      </p>\n      <p>\n      Registering to any of above events requires the application to provide a callback function. Each event provides different information, so it is recommended to consult the signature of the event listeners.\n      </p>\n      <p>\n      Flow control and congestion management is one of the most important features of WebRTC. WebRTC connections start with the lowest bandwidth configured and slowly ramps up to the maximum available bandwidth, or to the higher limit of the exploration range in case no bandwidth limitation is detected. Notice that WebRtcEndpoints in Kurento are designed in a way that multiple WebRTC connections fed by the same stream share quality. When a new connection is added, as it requires to start with low bandwidth, it will cause the rest of connections to experience a transient period of degraded quality, until it stabilizes its bitrate. This doesn't apply when transcoding is involved. Transcoders will adjust their output bitrate based in bandwidth requirements, but it won't affect the original stream. If an incoming WebRTC stream needs to be transcoded, for whatever reason, all WebRtcEndpoints fed from transcoder output will share a separate quality than the ones connected directly to the original stream.\n      </p>\n      <p>\n      The default bandwidth range of the endpoint is 100kbps-500kbps, but it can be changed separately for input/output directions and for audio/video streams.\n      <ul>\n        <li>\n          Input bandwidth control mechanism: Configuration interval used to inform remote peer the range of bitrates that can be pushed into this WebRtcEndpoint object.\n          <ul style='list-style-type:circle'>\n            <li>\n              setMin/MaxVideoRecvBandwidth: sets Min/Max bitrate limits expected for received video stream.\n            </li>\n            <li>\n              setMin/MaxAudioRecvBandwidth: sets Min/Max bitrate limits expected for received audio stream.\n            </li>\n          </ul>\n          Max values are announced in the SDP, while min values are set to limit the lower value of REMB packages. It follows that min values will only have effect in peers that support this control mechanism, such as Chrome.\n        </li>\n        <li>\n          Output bandwidth control mechanism: Configuration interval used to control bitrate of the output video stream sent to remote peer. It is important to keep in mind that pushed bitrate depends on network and remote peer capabilities. Remote peers can also announce bandwidth limitation in their SDPs (through the <code>b=<modifier>:<value></code> tag). Kurento will always enforce bitrate limitations specified by the remote peer over internal configurations.\n          <ul style='list-style-type:circle'>\n            <li>\n              setMin/MaxVideoSendBandwidth: sets Min/Max bitrate limits  for video sent to remote peer\n            </li>\n          </ul>\n        </li>\n      </ul>\n      All bandwidth control parameters must be changed before the SDP negotiation takes place, and can't be changed afterwards.\n      </p>\n      <p>\n      DataChannels allow other media elements that make use of the DataPad, to send arbitrary data. For instance, if there is a filter that publishes event information, it'll be sent to the remote peer through the channel. There is no API available for programmers to make use of this feature in the WebRtcElement. DataChannels can be configured to provide the following:\n      <ul>\n        <li>\n          Reliable or partially reliable delivery of sent messages\n        </li>\n        <li>\n          In-order or out-of-order delivery of sent messages\n        </li>\n      </ul>\n      Unreliable, out-of-order delivery is equivalent to raw UDP semantics. The message may make it, or it may not, and order is not important. However, the channel can be configured to be <i>partially reliable</i> by specifying the maximum number of retransmissions or setting a time limit for retransmissions: the WebRTC stack will handle the acknowledgments and timeouts.\n      </p>\n      <p>\n      The possibility to create DataChannels in a WebRtcEndpoint must be explicitly enabled when creating the endpoint, as this feature is disabled by default. If this is the case, they can be created invoking the createDataChannel method. The arguments for this method, all of them optional, provide the necessary configuration:\n      <ul>\n        <li>\n         <code>label</code>: assigns a label to the DataChannel. This can help identify each possible channel separately.\n        </li>\n        <li>\n          <code>ordered</code>: specifies if the DataChannel guarantees order, which is the default mode. If maxPacketLifetime and maxRetransmits have not been set, this enables reliable mode.\n        </li>\n        <li>\n          <code>maxPacketLifeTime</code>: The time window in milliseconds, during which transmissions and retransmissions may take place in unreliable mode. This forces unreliable mode, even if <code>ordered</code> has been activated.\n        </li>\n        <li>\n          <code>maxRetransmits</code>: maximum number of retransmissions that are attempted in unreliable mode. This forces unreliable mode, even if <code>ordered</code> has been activated.\n        </li>\n        <li>\n          <code>Protocol</code>: Name of the subprotocol used for data communication.\n        </li>\n      </ul>\n      ",
      "extends": "BaseRtpEndpoint",
      "constructor": {
        "params": [
          {
            "name": "mediaPipeline",
            "doc": "the :rom:cls:`MediaPipeline` to which the endpoint belongs",
            "type": "MediaPipeline"
          },
          {
            "name": "useDataChannels",
            "doc": "Activate data channels support",
            "type": "boolean",
            "optional": true,
            "defaultValue": false
          },
          {
            "name": "certificateKeyType",
            "doc": "Define the type of the certificate used in dtls",
            "type": "CertificateKeyType",
            "optional": true,
            "defaultValue": "RSA"
          }
        ],
        "doc": "Builder for the :rom:cls:`WebRtcEndpoint`"
      },
      "properties": [
        {
          "name": "stunServerAddress",
          "doc": "address of the STUN server (Only IP address are supported)",
          "type": "String"
        },
        {
          "name": "stunServerPort",
          "doc": "port of the STUN server",
          "type": "int"
        },
        {
          "name": "turnUrl",
          "doc": "TURN server URL with this format: <code>user:password@address:port(?transport=[udp|tcp|tls])</code>.</br><code>address</code> must be an IP (not a domain).</br><code>transport</code> is optional (UDP by default).",
          "type": "String"
        },
        {
          "name": "ICECandidatePairs",
          "doc": "the ICE candidate pair (local and remote candidates) used by the ice library for each stream.",
          "type": "IceCandidatePair[]",
          "readOnly": true
        },
        {
          "name": "IceConnectionState",
          "doc": "the ICE connection state for all the connections.",
          "type": "IceConnection[]",
          "readOnly": true
        }
      ],
      "methods": [
        {
          "params": [],
          "name": "gatherCandidates",
          "doc": "Start the gathering of ICE candidates.</br>It must be called after SdpEndpoint::generateOffer or SdpEndpoint::processOffer for Trickle ICE. If invoked before generating or processing an SDP offer, the candidates gathered will be added to the SDP processed."
        },
        {
          "params": [
            {
              "name": "candidate",
              "doc": "Remote ICE candidate",
              "type": "IceCandidate"
            }
          ],
          "name": "addIceCandidate",
          "doc": "Process an ICE candidate sent by the remote peer of the connection."
        },
        {
          "params": [
            {
              "name": "label",
              "doc": "Channel's label",
              "type": "String",
              "optional": true,
              "defaultValue": ""
            },
            {
              "name": "ordered",
              "doc": "If the data channel should guarantee order or not. If true, and maxPacketLifeTime and maxRetransmits have not been provided, reliable mode is activated.",
              "type": "boolean",
              "optional": true,
              "defaultValue": true
            },
            {
              "name": "maxPacketLifeTime",
              "doc": "The time window (in milliseconds) during which transmissions and retransmissions may take place in unreliable mode.</br>\n              .. note:: This forces unreliable mode, even if <code>ordered</code> has been activated",
              "type": "int",
              "optional": true,
              "defaultValue": -1
            },
            {
              "name": "maxRetransmits",
              "doc": "maximum number of retransmissions that are attempted in unreliable mode.</br>\n              .. note:: This forces unreliable mode, even if <code>ordered</code> has been activated",
              "type": "int",
              "optional": true,
              "defaultValue": -1
            },
            {
              "name": "protocol",
              "doc": "Name of the subprotocol used for data communication",
              "type": "String",
              "optional": true,
              "defaultValue": ""
            }
          ],
          "name": "createDataChannel",
          "doc": "Create a new data channel, if data channels are supported. If they are not supported, this method throws an exception.\n          Being supported means that the WebRtcEndpoint has been created with data channel support, the client also supports data channels, and they have been negotaited in the SDP exchange.\n          Otherwise, the method throws an exception, indicating that the operation is not possible.</br>\n          Data channels can work in either unreliable mode (analogous to User Datagram Protocol or UDP) or reliable mode (analogous to Transmission Control Protocol or TCP).\n          The two modes have a simple distinction:\n          <ul>\n            <li>Reliable mode guarantees the transmission of messages and also the order in which they are delivered. This takes extra overhead, thus potentially making this mode slower.</li>\n            <li>Unreliable mode does not guarantee every message will get to the other side nor what order they get there. This removes the overhead, allowing this mode to work much faster.</li>\n          </ul>"
        },
        {
          "params": [
            {
              "name": "channelId",
              "doc": "The channel identifier",
              "type": "int"
            }
          ],
          "name": "closeDataChannel",
          "doc": "Closes an open data channel"
        }
      ],
      "events": [
        "OnIceCandidate",
        "IceCandidateFound",
        "OnIceGatheringDone",
        "IceGatheringDone",
        "OnIceComponentStateChanged",
        "IceComponentStateChange",
        "OnDataChannelOpened",
        "DataChannelOpen",
        "OnDataChannelClosed",
        "DataChannelClose",
        "NewCandidatePairSelected"
      ]
    },
    {
      "name": "HttpPostEndpoint",
      "doc": "An :rom:cls:`HttpPostEndpoint` contains SINK pads for AUDIO and VIDEO, which provide access to an HTTP file upload function\n\n   This type of endpoint provide unidirectional communications. Its :rom:cls:`MediaSources <MediaSource>` are accessed through the :term:`HTTP` POST method.",
      "extends": "HttpEndpoint",
      "constructor": {
        "params": [
          {
            "name": "mediaPipeline",
            "doc": "the :rom:cls:`MediaPipeline` to which the endpoint belongs",
            "type": "MediaPipeline"
          },
          {
            "name": "disconnectionTimeout",
            "doc": "This is the time that an http endpoint will wait for a reconnection, in case an HTTP connection is lost.",
            "type": "int",
            "optional": true,
            "defaultValue": 2
          },
          {
            "name": "useEncodedMedia",
            "doc": "configures the endpoint to use encoded media instead of raw media. If the parameter is not set then the element uses raw media. Changing this parameter could affect in a severe way to stability because key frames lost will not be generated. Changing the media type does not affect to the result except in the performance (just in the case where original media and target media are the same) and in the problem with the key frames. We strongly recommended not to use this parameter because correct behaviour is not guarantied.",
            "type": "boolean",
            "optional": true,
            "defaultValue": false
          }
        ],
        "doc": "Builder for the :rom:cls:`HttpPostEndpoint`."
      },
      "events": [
        "EndOfStream"
      ]
    },
    {
      "name": "HttpEndpoint",
      "doc": "Endpoint that enables Kurento to work as an HTTP server, allowing peer HTTP clients to access media.",
      "abstract": true,
      "extends": "SessionEndpoint",
      "methods": [
        {
          "params": [],
          "return": {
            "type": "String",
            "doc": "The url as a String"
          },
          "name": "getUrl",
          "doc": "Obtains the URL associated to this endpoint"
        }
      ]
    },
    {
      "name": "Mixer",
      "doc": "A :rom:cls:`Hub` that allows routing of video between arbitrary port pairs and mixing of audio among several ports",
      "extends": "Hub",
      "constructor": {
        "params": [
          {
            "name": "mediaPipeline",
            "doc": "the :rom:cls:`MediaPipeline` to which the Mixer belongs",
            "type": "MediaPipeline"
          }
        ],
        "doc": "Create a :rom:cls:`Mixer` belonging to the given pipeline."
      },
      "methods": [
        {
          "params": [
            {
              "name": "media",
              "doc": "The sort of media stream to be connected",
              "type": "MediaType"
            },
            {
              "name": "source",
              "doc": "Source port to be connected",
              "type": "HubPort"
            },
            {
              "name": "sink",
              "doc": "Sink port to be connected",
              "type": "HubPort"
            }
          ],
          "name": "connect",
          "doc": "Connects each corresponding :rom:enum:`MediaType` of the given source port with the sink port."
        },
        {
          "params": [
            {
              "name": "media",
              "doc": "The sort of media stream to be disconnected",
              "type": "MediaType"
            },
            {
              "name": "source",
              "doc": "Audio source port to be disconnected",
              "type": "HubPort"
            },
            {
              "name": "sink",
              "doc": "Audio sink port to be disconnected",
              "type": "HubPort"
            }
          ],
          "name": "disconnect",
          "doc": "Disonnects each corresponding :rom:enum:`MediaType` of the given source port from the sink port."
        }
      ]
    },
    {
      "name": "PlayerEndpoint",
      "doc": "\n      <p>\n      Retrieves content from seekable or non-seekable sources, and injects them into :term:`KMS`, so they can be delivered to any Filter or Endpoint in the same MediaPipeline. Following URI schemas are supported:\n      <ul>\n        <li>\n          Files: Mounted in the local file system.\n          <ul><li>file:///path/to/file</li></ul>\n        </li>\n        <li>\n          RTSP: Those of IP cameras would be a good example.\n          <ul>\n            <li>rtsp://<server-ip></li>\n            <li>rtsp://username:password@<server-ip></li>\n          </ul>\n        </li>\n        <li>\n          HTTP: Any file available in an HTTP server\n          <ul>\n            <li>http(s)://<server-ip>/path/to/file</li>\n            <li>http(s)://username:password@<server-ip>/path/to/file</li>\n          </ul>\n        </li>\n      </ul>\n      </p>\n      <p>\n      For the player to stream the contents of the file, the server must have access to the resource. In case of local files, the user running the process must have read permissions over the file. For network resources, the path to the resource must be accessible: IP and port access not blocked, correct credentials, etc.The resource location can’t be changed after the player is created, and a new player should be created for streaming a different resource.\n      </p>\n      <p>\n      The list of valid operations is\n      <ul>\n        <li>*play*: starts streaming media. If invoked after pause, it will resume playback.</li>\n        <li>*stop*: stops streaming media. If play is invoked afterwards, the file will be streamed from the beginning.</li>\n        <li>*pause*: pauses media streaming. Play must be invoked in order to resume playback.</li>\n        <li>*seek*: If the source supports “jumps” in the timeline, then the PlayerEndpoint can\n          <ul>\n            <li>*setPosition*: allows to set the position in the file.</li>\n            <li>*getPosition*: returns the current position being streamed.</li>\n          </ul>\n        </li>\n      </ul>\n      </p>\n      <p>\n      <h2>Events fired:</h2>\n      <ul><li>EndOfStreamEvent: If the file is streamed completely.</li></ul>\n      </p>\n      ",
      "extends": "UriEndpoint",
      "constructor": {
        "params": [
          {
            "name": "mediaPipeline",
            "doc": "The :rom:cls:`MediaPipeline` this PlayerEndpoint belongs to.",
            "type": "MediaPipeline"
          },
          {
            "name": "uri",
            "doc": "URI pointing to the video. It has to be accessible to the KMS process.\n              <ul>\n                <li>Local resources: The user running the Kurento Media Server must have read permission over the file.</li>\n                <li>Remote resources: Must be accessible from the server where the media server is running.</li>\n              </ul>",
            "type": "String"
          },
          {
            "name": "useEncodedMedia",
            "doc": "use encoded instead of raw media. If the parameter is false then the element uses raw media. Changing this parameter can affect stability severely, as lost key frames will not be regenerated. Enabling this flag does not affect the overall behaviour, but has an impact in performance (just in case where original media and target media are the same). It will help solve the problem with lost key frames. We strongly recommended not to use this parameter because correct behaviour is not guarantied.",
            "type": "boolean",
            "optional": true,
            "defaultValue": false
          },
          {
            "name": "networkCache",
            "doc": "When using rtsp sources. Amount of ms to buffer",
            "type": "int",
            "optional": true,
            "defaultValue": 2000
          }
        ],
        "doc": "Create a PlayerEndpoint"
      },
      "properties": [
        {
          "name": "videoInfo",
          "doc": "Returns info about the source being played",
          "type": "VideoInfo",
          "readOnly": true
        },
        {
          "name": "position",
          "doc": "Get or set the actual position of the video in ms. .. note:: Setting the position only works for seekable videos",
          "type": "int64"
        }
      ],
      "methods": [
        {
          "params": [],
          "name": "play",
          "doc": "Starts reproducing the media, sending it to the :rom:cls:`MediaSource`. If the endpoint\n\n          has been connected to other endpoints, those will start receiving media."
        }
      ],
      "events": [
        "EndOfStream"
      ]
    },
    {
      "name": "AlphaBlending",
      "doc": "A :rom:cls:`Hub` that mixes the :rom:attr:`MediaType.AUDIO` stream of its connected sources and constructs one output with :rom:attr:`MediaType.VIDEO` streams of its connected sources into its sink",
      "extends": "Hub",
      "constructor": {
        "params": [
          {
            "name": "mediaPipeline",
            "doc": "the :rom:cls:`MediaPipeline` to which the dispatcher belongs",
            "type": "MediaPipeline"
          }
        ],
        "doc": "Create for the given pipeline"
      },
      "methods": [
        {
          "params": [
            {
              "name": "source",
              "doc": "The reference to the HubPort setting as master port",
              "type": "HubPort"
            },
            {
              "name": "zOrder",
              "doc": "The order in z to draw the master image",
              "type": "int"
            }
          ],
          "name": "setMaster",
          "doc": "Sets the source port that will be the master entry to the mixer"
        },
        {
          "params": [
            {
              "name": "relativeX",
              "doc": "The x position relative to the master port. Values from 0 to 1 are accepted. The value 0, indicates the coordinate 0 in the master image.",
              "type": "float"
            },
            {
              "name": "relativeY",
              "doc": "The y position relative to the master port. Values from 0 to 1 are accepted. The value 0, indicates the coordinate 0 in the master image.",
              "type": "float"
            },
            {
              "name": "zOrder",
              "doc": "The order in z to draw the images. The greatest value of z is in the top.",
              "type": "int"
            },
            {
              "name": "relativeWidth",
              "doc": "The image width relative to the master port width. Values from 0 to 1 are accepted.",
              "type": "float"
            },
            {
              "name": "relativeHeight",
              "doc": "The image height relative to the master port height. Values from 0 to 1 are accepted.",
              "type": "float"
            },
            {
              "name": "port",
              "doc": "The reference to the confingured port.",
              "type": "HubPort"
            }
          ],
          "name": "setPortProperties",
          "doc": "Configure the blending mode of one port."
        }
      ]
    },
    {
      "name": "RtpEndpoint",
      "doc": "Endpoint that provides bidirectional content delivery capabilities with remote networked peers through RTP or SRTP protocol. An :rom:cls:`RtpEndpoint` contains paired sink and source :rom:cls:`MediaPad` for audio and video. This endpoint inherits from :rom:cls:`BaseRtpEndpoint`.\n      </p>\n      <p>\n      In order to establish an RTP/SRTP communication, peers engage in an SDP negotiation process, where one of the peers (the offerer) sends an offer, while the other peer (the offeree) responds with an answer. This endpoint can function in both situations\n      <ul style='list-style-type:circle'>\n        <li>\n          As offerer: The negotiation process is initiated by the media server\n          <ul>\n            <li>KMS generates the SDP offer through the generateOffer method. This offer must then be sent to the remote peer (the offeree) through the signaling channel, for processing.</li>\n            <li>The remote peer process the Offer, and generates an Answer to this offer. The Answer is sent back to the media server.</li>\n            <li>Upon receiving the Answer, the endpoint must invoke the processAnswer method.</li>\n          </ul>\n        </li>\n        <li>\n          As offeree: The negotiation process is initiated by the remote peer\n          <ul>\n            <li>The remote peer, acting as offerer, generates an SDP offer and sends it to the WebRTC endpoint in Kurento.</li>\n            <li>The endpoint will process the Offer invoking the processOffer method. The result of this method will be a string, containing an SDP Answer.</li>\n            <li>The SDP Answer must be sent back to the offerer, so it can be processed.</li>\n          </ul>\n        </li>\n      </ul>\n      </p>\n      <p>\n      In case of unidirectional connections (i.e. only one peer is going to send media), the process is more simple, as only the emitter needs to process an SDP. On top of the information about media codecs and types, the SDP must contain the IP of the remote peer, and the port where it will be listening. This way, the SDP can be mangled without needing to go through the exchange process, as the receiving peer does not need to process any answer.\n      </p>\n      <p>\n      While there is no congestion control in this endpoint, the user can set some bandwidth limits that will be used during the negotiation process.\n      The default bandwidth range of the endpoint is 100kbps-500kbps, but it can be changed separately for input/output directions and for audio/video streams.\n      <ul style='list-style-type:circle'>\n        <li>\n          Input bandwidth control mechanism: Configuration interval used to inform remote peer the range of bitrates that can be pushed into this RtpEndpoint object. These values are announced in the SDP.\n          <ul>\n            <li>\n              setMaxVideoRecvBandwidth: sets Max bitrate limits expected for received video stream.\n            </li>\n            <li>\n              setMaxAudioRecvBandwidth: sets Max bitrate limits expected for received audio stream.\n            </li>\n          </ul>\n        </li>\n        <li>\n          Output bandwidth control mechanism: Configuration interval used to control bitrate of the output video stream sent to remote peer. Remote peers can also announce bandwidth limitation in their SDPs (through the b=<modifier>:<value> tag). Kurento will always enforce bitrate limitations specified by the remote peer over internal configurations.\n          <ul>\n            <li>\n              setMaxVideoSendBandwidth: sets Max bitrate limits for video sent to remote peer.\n            </li>\n            <li>\n              setMinVideoSendBandwidth: sets Min bitrate limits for audio sent to remote peer.\n            </li>\n          </ul>\n        </li>\n      </ul>\n      All bandwidth control parameters must be changed before the SDP negotiation takes place, and can't be modified afterwards.\n      TODO: What happens if the b=as tag form the SDP has a lower value than the one set in setMinVideoSendBandwidth?\n      </p>\n      <p>\n      Having no congestion ocntrol implementation means that the bitrate will remain constant. This is something to take into consideration when setting upper limits for the output bandwidth, or the local network connection can be overflooded.\n      </p>\n      ",
      "extends": "BaseRtpEndpoint",
      "constructor": {
        "params": [
          {
            "name": "mediaPipeline",
            "doc": "the :rom:cls:`MediaPipeline` to which the endpoint belongs",
            "type": "MediaPipeline"
          },
          {
            "name": "crypto",
            "doc": "SDES-type param. If present, this parameter indicates that the communication will be encrypted. By default no encryption is used.",
            "type": "SDES",
            "optional": true,
            "defaultValue": {}
          },
          {
            "name": "useIpv6",
            "doc": "This configures the endpoint to use IPv6 instead of IPv4.",
            "type": "boolean",
            "optional": true,
            "defaultValue": false
          }
        ],
        "doc": "Builder for the :rom:cls:`RtpEndpoint`"
      },
      "events": [
        "OnKeySoftLimit"
      ]
    },
    {
      "name": "RecorderEndpoint",
      "doc": "<p>\n      Provides the functionality to store contents. The recorder can store in local files or in a network resource. It receives a media stream from another MediaElement (i.e. the source), and stores it in the designated location.\n      </p>\n      <p>\n      The following information has to be provided In order to create a RecorderEndpoint, and can’t be changed afterwards:\n      <ul>\n        <li>\n          URI of the resource where media will be stored. Following schemas are supported:\n          <ul>\n            <li>\n              Files: mounted in the local file system.\n              <ul>\n                <li>file://<path-to-file></li>\n              </ul>\n            <li>\n              HTTP: Requires the server to support method PUT\n              <ul>\n                <li>\n                  http(s)://<server-ip>/path/to/file\n                </li>\n                <li>\n                  http(s)://username:password@<server-ip>/path/to/file\n                </li>\n              </ul>\n            </li>\n          </ul>\n        </li>\n        <li>\n          Relative URIs (with no schema) are supported. They are completed prepending a default URI defined by property defaultPath. This property allows using relative paths instead of absolute paths. If a relative path is provided, defaultPath will be prepended. This property is defined in the configuration file /etc/kurento/modules/kurento/UriEndpoint.conf.ini, and the default value is file:///var/kurento/\n        </li>\n        <li>\n          The media profile used to store the file. This will determine the encoding. See below for more details about media profile\n        </li>\n        <li>\n          Optionally, the user can select if the endpoint will stop processing once the EndOfStream event is detected.\n        </li>\n      </ul>\n      <p>\n      </p>\n      RecorderEndpoint requires access to the resource where stream is going to be recorded. If it’s a local file (file://), the system user running the media server daemon (kurento by default), needs to have write permissions for that URI. If it’s an HTTP server, it must be accessible from the machine where media server is running, and also have the correct access rights. Otherwise, the media server won’t be able to store any information, and an ErrorEvent will be fired. Please note that if you haven't subscribed to that type of event, you can be left wondering why your media is not being saved, while the error message was ignored.\n      <p>\n      </p>\n      The media profile is quite an important parameter, as it will determine whether there is a transcodification or not. If the input stream codec if not compatible with the selected media profile, the media will be transcoded into a suitable format, before arriving at the RecorderEndpoint's sink pad. This will result in a higher CPU load and will impact overall performance of the media server. For instance, if a VP8 encoded video received through a WebRTC endpoint arrives at the RecorderEndpoint, depending on the format configured in the recorder:\n      <ul>\n        <li>WEBM: No transcodification will take place.</li>\n        <li>MP4: The media server will have to transcode the media received from VP8 to H264. This will raise the CPU load in the system.</li>\n      </ul>\n      <p>\n      </p>\n      Recording will start as soon as the user invokes the record method. The recorder will then store, in the location indicated, the media that the source is sending to the endpoint’s sink. If no media is being received, or no endpoint has been connected, then the destination will be empty. The recorder starts storing information into the file as soon as it gets it.\n      <p>\n      </p>\n      When another endpoint is connected to the recorder, by default both AUDIO and VIDEO media types are expected, unless specified otherwise when invoking the connect method. Failing to provide both types, will result in teh recording buffering the received media: it won’t be written to the file until the recording is stopped. This is due to the recorder waiting for the other type of media to arrive, so they are synchronised.\n      <p>\n      </p>\n      The source endpoint can be hot-swapped, while the recording is taking place. The recorded file will then contain different feeds. When switching video sources, if the new video has different size, the recorder will retain the size of the previous source. If the source is disconnected, the last frame recorded will be shown for the duration of the disconnection, or until the recording is stopped.\n      <p>\n      </p>\n      It is recommended to start recording only after media arrives, either to the endpoint that is the source of the media connected to the recorder, to the recorder itself, or both. Users may use the MediaFlowIn and MediaFlowOut events, and synchronise the recording with the moment media comes in. In any case, nothing will be stored in the file until the first media packets arrive.\n      <p>\n      </p>\n      Stopping the recording process is done through the stopAndWait method, which will return only after all the information was stored correctly. If the file is empty, this means that no media arrived at the recorder.\n      </p>",
      "extends": "UriEndpoint",
      "constructor": {
        "params": [
          {
            "name": "mediaPipeline",
            "doc": "the :rom:cls:`MediaPipeline` to which the endpoint belongs",
            "type": "MediaPipeline"
          },
          {
            "name": "uri",
            "doc": "URI where the recording will be stored. It has to be accessible to the KMS process.\n              <ul>\n                <li>Local server resources: The user running the Kurento Media Server must have write permission over the file.</li>\n                <li>Network resources: Must be accessible from the server where the media server is running.</li>\n              </ul>",
            "type": "String"
          },
          {
            "name": "mediaProfile",
            "doc": "Sets the media profile used for recording. If the profile is different than the one being recieved at the sink pad, media will be trnascoded, resulting in a higher CPU load. For instance, when recording a VP8 encoded video from a WebRTC endpoint in MP4, the load is higher that when recording in WEBM.",
            "type": "MediaProfileSpecType",
            "optional": true,
            "defaultValue": "WEBM"
          },
          {
            "name": "stopOnEndOfStream",
            "doc": "Forces the recorder endpoint to finish processing data when an :term:`EOS` is detected in the stream",
            "type": "boolean",
            "optional": true,
            "defaultValue": false
          }
        ],
        "doc": ""
      },
      "methods": [
        {
          "params": [],
          "name": "record",
          "doc": "Starts storing media received through the sink pad."
        },
        {
          "params": [],
          "name": "stopAndWait",
          "doc": "Stops recording and does not return until all the content has been written to the selected uri. This can cause timeouts on some clients if there is too much content to write, or the transport is slow"
        }
      ],
      "events": [
        "Recording",
        "Paused",
        "Stopped"
      ]
    },
    {
      "name": "Dispatcher",
      "doc": "A :rom:cls:`Hub` that allows routing between arbitrary port pairs",
      "extends": "Hub",
      "constructor": {
        "params": [
          {
            "name": "mediaPipeline",
            "doc": "the :rom:cls:`MediaPipeline` to which the dispatcher belongs",
            "type": "MediaPipeline"
          }
        ],
        "doc": "Create a :rom:cls:`Dispatcher` belonging to the given pipeline."
      },
      "methods": [
        {
          "params": [
            {
              "name": "source",
              "doc": "Source port to be connected",
              "type": "HubPort"
            },
            {
              "name": "sink",
              "doc": "Sink port to be connected",
              "type": "HubPort"
            }
          ],
          "name": "connect",
          "doc": "Connects each corresponding :rom:enum:`MediaType` of the given source port with the sink port."
        }
      ]
    },
    {
      "name": "Composite",
      "doc": "A :rom:cls:`Hub` that mixes the :rom:attr:`MediaType.AUDIO` stream of its connected sources and constructs a grid with the :rom:attr:`MediaType.VIDEO` streams of its connected sources into its sink",
      "extends": "Hub",
      "constructor": {
        "params": [
          {
            "name": "mediaPipeline",
            "doc": "the :rom:cls:`MediaPipeline` to which the dispatcher belongs",
            "type": "MediaPipeline"
          }
        ],
        "doc": "Create for the given pipeline"
      }
    }
  ],
  "complexTypes": [
    {
      "typeFormat": "REGISTER",
      "properties": [
        {
          "name": "candidate",
          "doc": "The candidate-attribute as defined in section 15.1 of ICE (rfc5245).",
          "type": "String"
        },
        {
          "name": "sdpMid",
          "doc": "If present, this contains the identifier of the 'media stream identification'.",
          "type": "String"
        },
        {
          "name": "sdpMLineIndex",
          "doc": "The index (starting at zero) of the m-line in the SDP this candidate is associated with.",
          "type": "int"
        }
      ],
      "name": "IceCandidate",
      "doc": "IceCandidate representation based on standard (http://www.w3.org/TR/webrtc/#rtcicecandidate-type)."
    },
    {
      "typeFormat": "ENUM",
      "values": [
        "DISCONNECTED",
        "GATHERING",
        "CONNECTING",
        "CONNECTED",
        "READY",
        "FAILED"
      ],
      "name": "IceComponentState",
      "doc": "States of an ICE component."
    },
    {
      "typeFormat": "REGISTER",
      "properties": [
        {
          "name": "streamID",
          "doc": "Stream ID of the ice connection",
          "type": "String"
        },
        {
          "name": "componentID",
          "doc": "Component ID of the ice connection",
          "type": "int"
        },
        {
          "name": "localCandidate",
          "doc": "The local candidate used by the ice library.",
          "type": "String"
        },
        {
          "name": "remoteCandidate",
          "doc": "The remote candidate used by the ice library.",
          "type": "String"
        }
      ],
      "name": "IceCandidatePair",
      "doc": "The ICE candidate pair used by the ice library, for a certain stream."
    },
    {
      "typeFormat": "REGISTER",
      "properties": [
        {
          "name": "streamId",
          "doc": "The ID of the stream",
          "type": "String"
        },
        {
          "name": "componentId",
          "doc": "The ID of the component",
          "type": "int"
        },
        {
          "name": "state",
          "doc": "The state of the component",
          "type": "IceComponentState"
        }
      ],
      "name": "IceConnection",
      "doc": "The ICE connection state for a certain stream and component."
    },
    {
      "typeFormat": "ENUM",
      "values": [
        "RSA",
        "ECDSA"
      ],
      "name": "CertificateKeyType",
      "doc": "."
    },
    {
      "typeFormat": "REGISTER",
      "properties": [
        {
          "name": "isSeekable",
          "doc": "Seek is possible in video source",
          "type": "boolean"
        },
        {
          "name": "seekableInit",
          "doc": "First video position to do seek in ms",
          "type": "int64"
        },
        {
          "name": "seekableEnd",
          "doc": "Last video position to do seek in ms",
          "type": "int64"
        },
        {
          "name": "duration",
          "doc": "Video duration in ms",
          "type": "int64"
        }
      ],
      "name": "VideoInfo",
      "doc": ""
    },
    {
      "typeFormat": "ENUM",
      "values": [
        "WEBM",
        "MP4",
        "WEBM_VIDEO_ONLY",
        "WEBM_AUDIO_ONLY",
        "MP4_VIDEO_ONLY",
        "MP4_AUDIO_ONLY",
        "JPEG_VIDEO_ONLY",
        "KURENTO_SPLIT_RECORDER"
      ],
      "name": "MediaProfileSpecType",
      "doc": "Media Profile.\n\nCurrently WEBM, MP4 and JPEG are supported."
    },
    {
      "typeFormat": "ENUM",
      "values": [
        "AES_128_CM_HMAC_SHA1_32",
        "AES_128_CM_HMAC_SHA1_80",
        "AES_256_CM_HMAC_SHA1_32",
        "AES_256_CM_HMAC_SHA1_80"
      ],
      "name": "CryptoSuite",
      "doc": "Describes the encryption and authentication algorithms"
    },
    {
      "typeFormat": "REGISTER",
      "properties": [
        {
          "name": "key",
          "doc": " A string representing the cryptographic key used. The length varies depending on the cryptographic method used (30 bytes length for AES_128_CM, or 46 bytes length for AES_256_CM). If no key is provided a random one will be generated using the `getrandom` system call",
          "type": "String",
          "optional": true
        },
        {
          "name": "crypto",
          "doc": "Selects the cryptographic suite to be used. For available values, please see the CryptoSuite enum.",
          "type": "CryptoSuite",
          "optional": true
        }
      ],
      "name": "SDES",
      "doc": "Security Descriptions for Media Streams"
    }
  ],
  "events": [
    {
      "properties": [
        {
          "name": "candidate",
          "doc": "New local candidate",
          "type": "IceCandidate"
        }
      ],
      "extends": "Media",
      "name": "OnIceCandidate",
      "doc": "@deprecated</br>Notifies a new local candidate. These candidates should be sent to the remote peer, to complete the ICE negotiation process."
    },
    {
      "properties": [
        {
          "name": "candidate",
          "doc": "New local candidate",
          "type": "IceCandidate"
        }
      ],
      "extends": "Media",
      "name": "IceCandidateFound",
      "doc": "Notifies a new local candidate. These candidates should be sent to the remote peer, to complete the ICE negotiation process."
    },
    {
      "properties": [],
      "extends": "Media",
      "name": "OnIceGatheringDone",
      "doc": "@deprecated</br>Event fired when al ICE candidates have been gathered."
    },
    {
      "properties": [],
      "extends": "Media",
      "name": "IceGatheringDone",
      "doc": "Event fired when al ICE candidates have been gathered."
    },
    {
      "properties": [
        {
          "name": "streamId",
          "doc": "The ID of the stream",
          "type": "int"
        },
        {
          "name": "componentId",
          "doc": "The ID of the component",
          "type": "int"
        },
        {
          "name": "state",
          "doc": "The state of the component",
          "type": "IceComponentState"
        }
      ],
      "extends": "Media",
      "name": "OnIceComponentStateChanged",
      "doc": "@deprecated</br>Event fired when and ICE component state changes. See :rom:cls:`IceComponentState` for a list of possible states."
    },
    {
      "properties": [
        {
          "name": "streamId",
          "doc": "The ID of the stream",
          "type": "int"
        },
        {
          "name": "componentId",
          "doc": "The ID of the component",
          "type": "int"
        },
        {
          "name": "state",
          "doc": "The state of the component",
          "type": "IceComponentState"
        }
      ],
      "extends": "Media",
      "name": "IceComponentStateChange",
      "doc": "Event fired when and ICE component state changes. See :rom:cls:`IceComponentState` for a list of possible states."
    },
    {
      "properties": [
        {
          "name": "channelId",
          "doc": "The channel identifier",
          "type": "int"
        }
      ],
      "extends": "Media",
      "name": "OnDataChannelOpened",
      "doc": "@deprecated</br>Event fired when a new data channel is created."
    },
    {
      "properties": [
        {
          "name": "channelId",
          "doc": "The channel identifier",
          "type": "int"
        }
      ],
      "extends": "Media",
      "name": "DataChannelOpen",
      "doc": "Event fired when a new data channel is created."
    },
    {
      "properties": [
        {
          "name": "channelId",
          "doc": "The channel identifier",
          "type": "int"
        }
      ],
      "extends": "Media",
      "name": "OnDataChannelClosed",
      "doc": "@deprecated</br>Event fired when a data channel is closed."
    },
    {
      "properties": [
        {
          "name": "channelId",
          "doc": "The channel identifier",
          "type": "int"
        }
      ],
      "extends": "Media",
      "name": "DataChannelClose",
      "doc": "Event fired when a data channel is closed."
    },
    {
      "properties": [
        {
          "name": "candidatePair",
          "doc": "The new pair of candidates",
          "type": "IceCandidatePair"
        }
      ],
      "extends": "Media",
      "name": "NewCandidatePairSelected",
      "doc": "Event fired when a new pair of ICE candidates is used by the ICE library. This could also happen in the middle of a session, though not likely."
    },
    {
      "properties": [
        {
          "name": "mediaType",
          "doc": "The media stream",
          "type": "MediaType"
        }
      ],
      "extends": "Media",
      "name": "OnKeySoftLimit",
      "doc": "Fired when encryption is used and any stream reached the soft key usage limit, which means it will expire soon."
    },
    {
      "properties": [],
      "extends": "Media",
      "name": "EndOfStream",
      "doc": "Event raised when the stream that the element sends out is finished."
    },
    {
      "properties": [],
      "extends": "Media",
      "name": "Recording",
      "doc": "Fired when the recoding effectively starts. ie: Media is received by the recorder and record method has been called."
    },
    {
      "properties": [],
      "extends": "Media",
      "name": "Paused",
      "doc": "@deprecated</br>Fired when the recorder goes to pause state"
    },
    {
      "properties": [],
      "extends": "Media",
      "name": "Stopped",
      "doc": "@deprecated</br>Fired when the recorder has been stopped and all the media has been written to storage."
    }
  ]
}
