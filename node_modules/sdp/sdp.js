var _ = require('underscore');
var each = _.each;
var filter = _.filter;


var Session = exports.Session = function (opts) {
    var self = this;

    self.version = '0';
    self.origin = {};
    self.name = '-';
    self.media = [];
    self.connection = {};
    self.bandwidth = {};
    self.attributes = [];

    _.extend(self, opts || {});
};
Session.prototype = {
    constructor: {
        value: Session
    },
    fromSDP: function (sdp) {
        exports.parse(sdp, this); 
    },
    toSDP: function () {
        var self = this;
        var lines = [];

        lines.push('v=' + this.version);

        lines.push('o=' + this.origin.username + 
                   ' ' + this.origin.sessionID + 
                   ' ' + this.origin.sessionVersion +
                   ' ' + this.origin.netType + 
                   ' ' + this.origin.addrType + 
                   ' ' + this.origin.address);

        lines.push('s=' + this.name);

        if (Object.keys(this.connection).length) {
            lines.push('c=' + this.connection.netType +
                       ' ' + this.connection.addrType +
                       ' ' + this.connection.address);
        }

        each(this.bandwidth, function (val, key) {
            lines.push('b=' + key + ' ' + val);
        });

        lines.push('t=0 0');

        each(this.attributes, function (attr) {
            if (attr.value === true) {
                lines.push('a=' + attr.key);
            } else {
                lines.push('a=' + attr.key + ':' + attr.value);
            }
        });

        each(this.media, function (media) {
            media.toSDP(lines);    
        });

        return lines.join('\r\n');
    },
    get headerExtensions() {
        var results = [];
        each(this.attributes, function (attr) {
            if (attr.key === 'extmap') {
                var parsed = attr.value.split(' '),
                ext = {};
                ext.value = parsed.shift();
                if (ext.value.indexOf('/') != -1) {
                    ext.direction = ext.value.substr(ext.value.indexOf('/') + 1);
                    ext.value = ext.value.substr(0, ext.value.indexOf('/'));
                } else {
                    ext.direction = 'both';
                }
                ext.uri = parsed.shift();
                ext.params = parsed;

                results.push(ext);
            }
        });

        return results;
    }
};


var Media = exports.Media = function (opts) {
    var self = this;

    self.type = '';
    self.port = undefined;
    self.numberOfPorts = undefined;
    self.proto = undefined;
    self.formats = [];
    self.connection = {};
    self.bandwidth = {};
    self.attributes = [];

    _.extend(self, opts || {});
};
Media.prototype = {
    constructor: {
        value: Media
    },
    toSDP: function (lines) {
        var self = this;
        lines = lines || [];

        lines.push('m=' + this.type + 
                   ' ' + this.port +
                   ((this.numberOfPorts > 1) ? '/' + this.numberOfPorts : '') +
                   ' ' + this.proto +
                   ' ' + this.formats.join(' '));

        if (Object.keys(this.connection).length) {
            lines.push('c=' + this.connection.netType +
                       ' ' + this.connection.addrType +
                       ' ' + this.connection.address);
        }

        each(this.bandwidth, function (val, key) {
            lines.push('b=' + key + ' ' + val);
        });

        each(this.attributes, function (attr) {
            if (attr.value === true) {
                lines.push('a=' + attr.key);
            } else {
                lines.push('a=' + attr.key + ':' + attr.value);
            }
        });

        return lines.join('\r\n');
    },
    get payloadTypes() {
        var payloads = {};
        var vals = '';

        each(this.formats, function (fmtID) {
            payloads[fmtID] = {
                feedback: [],
                parameters: []
            };
        });
        each(this.attributes, function (attr) {
            var parsed, codec;
            if (attr.key === 'rtpmap') {
                parsed = (/^(\d+) ?(.*)/).exec(attr.value);
                if (parsed) {
                    codec = parsed[1];
                    vals = parsed[2].split(/\//);

                    if (payloads[codec]) {
                        payloads[codec].id = codec;
                        payloads[codec].name = vals[0];
                        payloads[codec].clockrate = vals[1] || undefined;
                        payloads[codec].channels = vals[2] || 1;
                    }
                }
                return;
            }
            if (attr.key === 'fmtp') {
                parsed = (/^(\d+) ?(.*)/).exec(attr.value);
                if (parsed) {
                    codec = parsed[1];
                    vals = parsed[2].split(/;/);

                    if (payloads[codec]) {
                        each(vals, function (val) {
                            var parsed = val.split('=');
                            var key = parsed[0].trim();
                            var value = (parsed[1] || '').trim();

                            if (key) {
                                payloads[codec].parameters.push({key: key, value: value});
                            }
                        });
                    }
                }
                return;
            }
            if (attr.key === 'rtcp-fb') {
                parsed = attr.value.split(' ');
                codec = parsed.shift();

                var fb = {
                    type: parsed.shift() || '',
                    subtype: parsed.shift() || '',
                    params: parsed
                };

                if (codec !== '*' && payloads[codec]) {
                    payloads[codec].feedback.push(fb);
                }
                return;
            }
        });

        var results = [];
        each(payloads, function (payload) {
            results.push(payload);
        });
        return results;
    },
    set payloadTypes(val) {
        var self = this;
        each(val, function (payload) {
            var payloadOpts = [payload.name];
            if (payload.clockrate) {
                payloadOpts.push(payload.clockrate);
            }
            if (payload.channels > 1) {
                payloadOpts.push(payload.channels);
            }
            self.attributes.push({
                key: 'rtpmap',
                value: payload.id + ' ' + payloadOpts.join('/')
            });

            payload.parameters = payload.parameters || [];
            if (payload.parameters.length) {
                var parameters = [];
                each(payload.parameters, function (param) {
                    parameters.push(param.key + '=' + param.value + ';');
                });
                self.attributes.push({
                    key: 'fmtp',
                    value: payload.id + ' ' + parameters.join(' ')
                });
            }

            payload.feedback = payload.feedback || [];
            each(payload.feedback, function (fb) {
                self.attributes.push({
                    key: 'rtcp-fb',
                    value: [payload.id, fb.type, fb.subtype, fb.params.join(' ')].join(' ')
                });
            });
        });
    },
    get feedback() {
        var results = [];
        each(this.attributes, function (attr) {
            if (attr.key === 'rtcp-fb') {
                var parsed = attr.value.split(' ');
                var codec = parsed.shift();
                var fb = {
                    type: parsed.shift() || '',
                    subtype: parsed.shift() || '',
                    params: parsed
                };

                if (codec === '*') {
                    results.push(fb);
                }
            }
        });
        return results;
    },
    set feedback(val) {
        var self = this;
        each(val, function (fb) {
            self.attributes.push({
                key: 'rtcp-fb',
                value: ['*', fb.type, fb.params.join(' ')].join(' ')
            });
        });
    },
    get ice() {
        var result = {
            pwd: '',
            ufrag: ''
        };
        var iceLines = filter(this.attributes, function (attr) {
            return attr.key === 'ice-pwd' || attr.key === 'ice-ufrag';
        });

        each(iceLines, function (attr) {
            if (attr.key === 'ice-pwd') {
                result.pwd = attr.value;
                return;
            }
            if (attr.key === 'ice-ufrag') {
                result.ufrag = attr.value;
                return;
            }
        });

        return result;
    },
    set ice(val) {
        if (val.ufrag) {
            this.attributes.push({
                key: 'ice-ufrag',
                value: val.ufrag
            });
        }
        if (val.pwd) {
            this.attributes.push({
                key: 'ice-pwd',
                value: val.pwd
            });
        }
    },
    get candidates() {
        var results = [];

        var candidateLines = filter(this.attributes, function (attr) {
            return attr.key === 'candidate';
        });

        each(candidateLines, function (attr) {
            var parsed = attr.value.split(' ');
            var candidate = {};

            candidate.foundation = parsed.shift();
            candidate.component = parsed.shift();
            candidate.protocol = parsed.shift();
            candidate.priority = parsed.shift();
            candidate.ip = parsed.shift();
            candidate.port = parsed.shift();
            for (var i = 0; i < parsed.length; i += 2) {
                switch (parsed[i]) {
                case 'typ':
                    candidate.type = parsed[i + 1];
                    break;
                case 'raddr':
                    candidate['rel-addr'] = parsed[i + 1];
                    break;
                case 'rport':
                    candidate['rel-port'] = parsed[i + 1];
                    break;
                case 'generation':
                    candidate.generation = parsed[i + 1];
                    break;
                }
            }
            candidate.network = '1';

            results.push(candidate);
        });

        return results;
    },
    set candidates(val) {
        var self = this;
        each(val, function (candidate) {
            var line = [
                candidate.foundation,
                candidate.component,
                candidate.protocol,
                candidate.priority,
                candidate.ip,
                candidate.port,
                'typ',
                candidate.type
            ].join(' ');

            if (candidate['rel-addr']) {
                line += ' raddr ' + candidate['rel-addr'];
            }
            if (candidate['rel-port']) {
                line += ' rport ' + candidate['rel-port'];
            }

            line += ' generation ' + candidate.generation;

            self.attributes.push({
                key: 'candidate',
                value: line
            });
        });
    },
    get remoteCandidates() {
        var results = [];

        var candidateLines = filter(this.attributes, function (attr) {
            return attr.key === 'remote-candidate';
        });

        each(candidateLines, function (attr) {
            var parsed = attr.value.split(' ');
            var candidate = {};

            candidate.component = parsed.shift();
            candidate.ip = parsed.shift();
            candidate.port = parsed.shift();

            results.push(candidate);
        });

        return results;
    },
    set remoteCandidates(val) {
        var self = this;
        each(val, function (candidate) {
            self.attributes.push({
                key: 'remote-candidate',
                value: [candidate.component, candidate.ip, candidate.port].join(' ')
            });
        });
    },
    get fingerprint() {
        var result = {};
        each(this.attributes, function (attr) {
            if (attr.key === 'fingerprint') {
                var parsed = attr.value.split(' ');
                result.hash = parsed[0];
                result.value = parsed[1];
            }
        });
        return result;
    },
    set fingerprint(val) {
        this.attributes.push({
            key: 'fingerprint',
            value: val.hash + ' ' + val.value
        });
    },
    get encryption() {
        var results = [];

        var cryptoLines = filter(this.attributes, function (attr) {
            return attr.key === 'crypto';
        });

        each(cryptoLines, function (attr) {
            var parsed = attr.value.split(' ');
            var crypto = {};

            crypto.tag = parsed.shift();
            crypto.cryptoSuite = parsed.shift();
            crypto.keyParams = parsed.shift();
            if (parsed.length) {
                crypto.sessionParams = parsed.join(' ');
            }

            results.push(crypto);
        });

        return results;
    },
    set encryption(val) {
        var self = this;
        each(val, function (crypto) {
            self.attributes.push({
                key: 'crypto',
                value: [crypto.tag, crypto.cryptoSuite, crypto.keyParams, crypto.sessionParams].join(' ')
            });
        });
    },
    get rtcp() {
        var result = {};
        each(this.attributes, function (attr) {
            if (attr.key === 'rtcp') {
                var parsed = attr.value.split(' ');
                result.port = parsed[0];
                result.netType = parsed[1];
                result.addrType = parsed[2];
                result.address = parsed[3];
            }
        });
        return result;
    },
    set rtcp(val) {
        this.attributes.push({
            key: 'rtcp',
            value: [val.port, val.netType, val.addrType, val.address].join(' ')
        });
    },
    get headerExtensions() {
        var results = [];
        each(this.attributes, function (attr) {
            if (attr.key === 'extmap') {
                var parsed = attr.value.split(' ');
                var ext = {};
                ext.value = parsed.shift();
                if (ext.value.indexOf('/') != -1) {
                    ext.direction = ext.value.substr(ext.value.indexOf('/') + 1);
                    ext.value = ext.value.substr(0, ext.value.indexOf('/'));
                } else {
                    ext.direction = 'both';
                }
                ext.uri = parsed.shift();
                ext.params = parsed;

                results.push(ext);
            }
        });
        return results;
    },
    set headerExtensions(val) {
        var self = this;
        each(val, function (ext) {
            self.attributes.push({
                key: 'extmap',
                value: [
                    ext.value, 
                    (ext.direction === 'both' ? '' : '/' + ext.direction),
                    ext.uri,
                    ext.params.join(' ')
                ].join(' ')
            });
        });
    },
    get streamMode() {
        var result = '';
        each(this.attributes, function (attr) {
            if (attr.key === 'sendrecv' || attr.key === 'recvonly' || attr.key === 'sendonly' || attr.key === 'inactive') {
                result = attr.key;
            }
        });
        return result;
    },
    set streamMode(val) {
        this.attributes = _.filter(this.attributes, function (attr) {
            return attr.key !== 'inactive' && attr.key !== 'sendonly' && attr.key !== 'recvonly' && attr.key !== 'sendrecv';
        });
        this.attributes.push({
            key: val,
            value: true
        });
    }
};



var LINE_PARSERS = {
    v: function (curr, value) {
        curr.version = value;
    },
    o: function (curr, value) {
        var parsed = value.split(/\s+/);
        curr.origin = {
            username: parsed[0],
            sessionID: parsed[1],
            sessionVersion: parsed[2],
            netType: parsed[3],
            addrType: parsed[4],
            address: parsed[5]
        };
    },
    s: function (curr, value) {
        curr.name = value;
    },
    c: function (curr, value) {
        var parsed = value.split(/\s+/);
        curr.connection = {
            netType: parsed[0],
            addrType: parsed[1],
            address: parsed[2]
        };
    },
    m: function (curr, value) {
        var parsed = (/^(\w+) +(\d+)(?:\/(\d))? +(\S+) (\d+( +\d+)*)/).exec(value);
        if (parsed) {
            curr.type = parsed[1];
            curr.port = parseInt(parsed[2], 10);
            curr.numberOfPorts = parseInt(parsed[3] || '1', 10);
            curr.proto = parsed[4];
            curr.formats = parsed[5].split(' ');
        }
    },
    a: function (curr, value) {
        var parsed = (/^([\w-]+)(?::(.*))?$/).exec(value);
        if (parsed) {
            curr.attributes.push({
                key: parsed[1],
                value: parsed[2] || true
            });
        }
    },
    b: function (curr, value) {
        var parsed = (/^([\w-]+)(?::(.*))?$/).exec(value);
        if (parsed) {
            curr.bandwidth[parsed[1]] = parsed[2] || null;
        }
    }
};

exports.parse = function (sdp, existingSession) {
    var session = existingSession || new Session();
    var lines = sdp.split(/\r?\n/);
    var curr = session;

    for (var i = 0; i < lines.length; i++) {
        var data = (/^(\w)=(.*)/).exec(lines[i]);
        if (data) {
            var lineType = data[1];
            var lineValue = data[2];

            if (lineType === 'm') {
                var media = new Media();
                session.media.push(media);
                curr = media;
            }

            if (LINE_PARSERS[lineType]) {
                LINE_PARSERS[lineType](curr, lineValue);
            }
        }
    }

    return session;
};
