/*
 * rtcninja-temasys.js v0.3.4
 * rtcninja.js module for the Temasys WebRTC plugin.
 * Copyright 2015 Temasys Communications Pte Ltd
 * Copyright 2015-2016 IÃ±aki Baz Castillo <inaki.baz@eface2face.com> (http://eface2face.com)
 * License Apache-2.0
 *
 * The original source has been modified in order to change the exposed API.
 */

(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.rtcninjaTemasys = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (global){
/**
 * Expose the TemasysPlugin function/object.
 */
module.exports = TemasysPlugin;

/**
 * Dependencies.
 */
var browser = require('bowser');
var domready = require('domready');
var merge = require('merge');
var debug = require('debug')('rtcninja:TemasysPlugin');

/**
 * Local variables.
 */
var getUserMedia = null;
var RTCPeerConnection = null;
var RTCSessionDescription = null;
var RTCIceCandidate = null;
var MediaStreamTrack = null;
var attachMediaStream = null;
var canRenegotiate = true;
var browserVersion = Number(browser.version) || 0;
var isDesktop = !!(!browser.mobile && (!browser.tablet || (browser.msie && browserVersion >= 10)));
var isWin = !!navigator.platform.match(/^Win/i);
var isMac = !!navigator.platform.match(/^Mac/i);

// The plugin HTML element.
var plugin = null;

// Plugin options. Extensible via API.
var pluginOptions =
{
	getAllCams: false
};

// Plugin information.
var pluginInfo =
{
	prefix       : 'Tem',
	plugName     : 'TemWebRTCPlugin',
	pluginId     : 'plugin0',
	type         : 'application/x-temwebrtcplugin',
	onload       : '__onTemasysPluginReady',
	portalLink   : 'http://temasys.atlassian.net/wiki/display/TWPP/WebRTC+Plugins',
	downloadLink : null,
	companyName  : 'Temasys'
};

// The plugin API interface.
var pluginInterface = {};

if (isMac)
{
	pluginInfo.downloadLink = 'http://bit.ly/1n77hco';
}
else if (isWin)
{
	pluginInfo.downloadLink = 'http://bit.ly/1kkS4FN';
}

// Unique identifier of each opened page.
var pageId = Math.random().toString(36).slice(2);

// Plugin possible states.
var PLUGIN_STATES =
{
	NONE         : 0,  // No plugin use.
	INITIALIZING : 1,  // Detected need for plugin.
	INJECTING    : 2,  // Injecting plugin.
	INJECTED     : 3,  // Plugin element injected but not usable yet.
	READY        : 4   // Plugin ready to be used.
};

// Plugin current state.
var pluginState = PLUGIN_STATES.NONE;

/**
 * Private API.
 */

global.__onTemasysPluginReady = function()
{
	debug('__onTemasysPluginReady()');

	domready(function()
	{
		pluginState = PLUGIN_STATES.READY;
	});
};

function addEvent(elem, evnt, func)
{
	// W3C DOM.
	if (elem.addEventListener)
	{
		elem.addEventListener(evnt, func, false);
	}
	// Old IE DOM.
	else if (elem.attachEvent)
	{
		elem.attachEvent('on' + evnt, func);
	}
}

function injectPlugin()
{
	debug('injectPlugin()');

	// Prevent multiple injections.
	if (pluginState !== PLUGIN_STATES.INITIALIZING)
	{
		return;
	}

	pluginState = PLUGIN_STATES.INJECTING;

	// Internet Explorer <= 10.
	if (browser.msie && browserVersion <= 10)
	{
		var frag = document.createDocumentFragment();

		plugin = document.createElement('div');
		plugin.innerHTML = '<object id="' +
			pluginInfo.pluginId + '" type="' +
			pluginInfo.type + '" ' + 'width="1" height="1">' +
			'<param name="pluginId" value="' + pluginInfo.pluginId + '" />' +
			'<param name="windowless" value="false" />' +
			'<param name="pageId" value="' + pageId + '" />' +
			'<param name="onload" value="' + pluginInfo.onload + '" />' +
			(pluginOptions.getAllCams ? '<param name="forceGetAllCams" value="True" />' : '') +
			'</object>';

		while (plugin.firstChild)
		{
			frag.appendChild(plugin.firstChild);
		}
		document.body.appendChild(frag);

		// Need to re-fetch the plugin
		plugin = document.getElementById(pluginInfo.pluginId);
	}
	// Internet Explorer > 10 or Safari.
	else
	{
		plugin = document.createElement('object');
		plugin.id = pluginInfo.pluginId;

		if (browser.msie)
		{
			// IE will only start the plugin if it's ACTUALLY visible.
			plugin.width = '1px';
			plugin.height = '1px';
		}
		else if (browser.safari)
		{
			// The size of the plugin on Safari should be 0x0px so that the
			// autorization prompt is at the top.
			plugin.width = '0px';
			plugin.height = '0px';
		}

		plugin.type = pluginInfo.type;
		plugin.innerHTML = '<param name="onload" value="' + pluginInfo.onload + '">' +
			'<param name="pluginId" value="' + pluginInfo.pluginId + '">' +
			'<param name="windowless" value="false" /> ' +
			(pluginOptions.getAllCams ? '<param name="forceGetAllCams" value="True" />' : '') +
			'<param name="pageId" value="' + pageId + '">';

		document.body.appendChild(plugin);
	}

	pluginState = PLUGIN_STATES.INJECTED;
}

function waitForPluginReady()
{
	while (pluginState !== PLUGIN_STATES.READY) {}  // jshint ignore:line
}

function callWhenPluginReady(callback)
{
	if (pluginState === PLUGIN_STATES.READY)
	{
		callback();
	}
	else
	{
		// Otherwise start a 100ms interval.
		var checkPluginReadyState = setInterval(function ()
		{
			if (pluginState === PLUGIN_STATES.READY)
			{
				clearInterval(checkPluginReadyState);
				callback();
		  }
		}, 100);
	}
}

function defineWebRTCInterface()
{
	debug('defineWebRTCInterface()');

	pluginState = PLUGIN_STATES.INITIALIZING;

	getUserMedia = function(constraints, successCallback, failureCallback)
	{
		constraints = constraints || {};
		constraints.audio = constraints.audio || false;
		constraints.video = constraints.video || false;

		callWhenPluginReady(function ()
		{
			plugin.getUserMedia(constraints, successCallback, failureCallback);
		});
	};

	RTCPeerConnection = function(pcConfig)
	{
		pcConfig = pcConfig || {};
		pcConfig.iceServers = pcConfig.iceServers || [];

		waitForPluginReady();

		return plugin.PeerConnection(pcConfig);
	};

	RTCSessionDescription = function(data)
	{
		waitForPluginReady();

		return plugin.ConstructSessionDescription(data.type, data.sdp);
	};

	RTCIceCandidate = function(candidate)
	{
		waitForPluginReady();

		return plugin.ConstructIceCandidate(candidate.sdpMid || '', candidate.sdpMLineIndex, candidate.candidate);
	};

	MediaStreamTrack = function() {};

	MediaStreamTrack.getSources = function(callback)
	{
		callWhenPluginReady(function ()
		{
			plugin.GetSources(callback);
		});
	};

	attachMediaStream = function(element, stream)
	{
		if (!element || !element.parentNode)
		{
			return;
		}

		var streamId;

		if (!stream)
		{
			streamId = '';
		}
		else
		{
			try
			{
				// TODO: Deprecated (may be already)
				stream.enableSoundTracks(true);
			}
			catch (error) {}

			streamId = stream.id;
		}

		var elementId = element.id.length === 0 ? Math.random().toString(36).slice(2) : element.id;
		var nodeName = element.nodeName.toLowerCase();

		// Not a plugin <object> tag yet.
		if (nodeName !== 'object')
		{
			var tag;

			switch (nodeName)
			{
				case 'audio':
					tag = 'audio';
					break;
				case 'video':
					tag = 'video';
					break;
				default:
					tag = 'none';
			}

			var frag = document.createDocumentFragment();
			var temp = document.createElement('div');
			var classHTML = '';

			if (element.className)
			{
				classHTML = 'class="' + element.className + '" ';
			}
			else if (element.attributes && element.attributes['class'])
			{
				classHTML = 'class="' + element.attributes['class'].value + '" ';
			}

			temp.innerHTML =
				'<object id="' + elementId + '" ' + classHTML +
				  'type="' + pluginInfo.type + '">' +
				  '<param name="pluginId" value="' + elementId + '" /> ' +
				  '<param name="pageId" value="' + pageId + '" /> ' +
				  '<param name="windowless" value="true" /> ' +
				  '<param name="streamId" value="' + streamId + '" /> ' +
				  '<param name="tag" value="' + tag + '" /> ' +
			  '</object>';

			while (temp.firstChild)
			{
			 	frag.appendChild(temp.firstChild);
			}

			var height = '';
			var width = '';

			if (element.getBoundingClientRect)
			{
				var rectObject = element.getBoundingClientRect();

				width = rectObject.width + 'px';
				height = rectObject.height + 'px';
			}
			else if (element.width)
			{
				width = element.width;
				height = element.height;
			}
			// TODO: What scenario could bring us here?
			else
			{}  // jshint ignore:line

			element.parentNode.insertBefore(frag, element);
			frag = document.getElementById(elementId);
			frag.width = width;
			frag.height = height;
			element.parentNode.removeChild(element);
		}
		// Already a <object> tag, just change the stream id.
		else
		{
			var children = element.children;

			for (var i = 0; i !== children.length; ++i)
			{
			  if (children[i].name === 'streamId')
			  {
			    children[i].value = streamId;
			    break;
			  }
			}
			element.setStreamId(streamId);
		}

		var newElement = document.getElementById(elementId);

		newElement.onplaying = (element.onplaying) ? element.onplaying : function () {};
		newElement.onplay = (element.onplay) ? element.onplay : function () {};
		newElement.onclick = (element.onclick) ? element.onclick : function () {};

		// On IE the event needs to be plugged manually.
		if (browser.msie)
		{
			addEvent(newElement, 'playing', newElement.onplaying);
			addEvent(newElement, 'play', newElement.onplay);
			newElement.onclick = (element.onclick) ? element.onclick : function () {};
			newElement._TemOnClick = function (id)
			{
				var arg =
				{
					srcElement : document.getElementById(id)
				};

				newElement.onclick(arg);
			};
		}

		return newElement;
	};

	// Inject the plugin into the HTML.
	domready(function()
	{
		injectPlugin();
	});
}

/**
 * Public API.
 */

function TemasysPlugin(options, info, alreadyInstalledCb, needInstallCb, notRequiredCb)
{
	if (!TemasysPlugin.isRequired())
	{
		if (notRequiredCb)
		{
			notRequiredCb();
		}

		return;
	}

	info = info || {};

	merge(pluginOptions, options);
	merge(pluginInfo, info);

	debug('TemasysPlugin() [pluginOptions:%o, pluginInfo:%o]', pluginOptions, pluginInfo);

	if (isMac && info.downloadLinkSafari)
	{
		pluginInfo.downloadLink = info.downloadLinkSafari;
	}
	else if (isWin && info.downloadLinkIE)
	{
		pluginInfo.downloadLink = info.downloadLinkIE;
	}

	if (TemasysPlugin.isInstalled())
	{
		debug('plugin already installed');

		defineWebRTCInterface();

		pluginInterface.getUserMedia = getUserMedia;
		pluginInterface.RTCPeerConnection = RTCPeerConnection;
		pluginInterface.RTCSessionDescription = RTCSessionDescription;
		pluginInterface.RTCIceCandidate = RTCIceCandidate;
		pluginInterface.MediaStreamTrack = MediaStreamTrack;
		pluginInterface.attachMediaStream = attachMediaStream;
		pluginInterface.canRenegotiate = canRenegotiate;

		if (alreadyInstalledCb)
		{
			alreadyInstalledCb();
		}
	}
	else
	{
		debug('plugin required but not installed');

		pluginInterface = {};

		if (needInstallCb)
		{
			needInstallCb(
				{
					isIE         : browser.msie,
					isSafari     : browser.safari,
					downloadLink : pluginInfo.downloadLink
				});
		}
	}
}

TemasysPlugin.isRequired = function()
{
	if (isDesktop && browser.msie && isWin)
	{
		return true;
	}
	else if (isDesktop && browser.safari && isMac)
	{
		return true;
	}
	else
	{
		return false;
	}
};

TemasysPlugin.isInstalled = function()
{
	// Safari.
	if (browser.safari)
	{
		var plugins = navigator.plugins;

		for (var i=0, len=plugins.length; i<len; i++)
		{
			if (plugins[i].name.indexOf(pluginInfo.plugName) >= 0)
			{
				return true;
			}
		}

		return false;
	}
	// IE.
	else if (browser.msie)
	{
		try
		{
			var axo = new global.ActiveXObject(pluginInfo.prefix + '.' + pluginInfo.plugName);  // jshint ignore:line

			return true;
		}
		catch (error)
		{
			return false;
		}
	}
};

TemasysPlugin.monitorPluginInstallation = function(installedCb, monitorEndCb, interval, maxtime)
{
	if (browser.safari)
	{
		debug('monitorPluginInstallation() | Safari requires restart, cannot monitor plugin installation');
		return false;
	}

	interval = Number(interval);
	maxtime = Number(maxtime);
	if (!interval) { interval = 3000;   }
	if (!maxtime)  { maxtime  = 180000; }

	debug('monitorPluginInstallation() | [interval: %dms | maxtime: %dms]', interval, maxtime);

	var timer = null;
	var periodicTimer = setInterval(function()
	{
		if (TemasysPlugin.isInstalled())
		{
			debug('monitorPluginInstallation() | plugin installed');

			clearInterval(periodicTimer);
			clearTimeout(timer);

			TemasysPlugin();  // jshint ignore:line

			if (installedCb) { installedCb(); }
		}
	}, interval);

	timer = setTimeout(function()
	{
		debug('monitorPluginInstallation() | monitoring ended');

		clearInterval(periodicTimer);

		if (monitorEndCb) { monitorEndCb(); }
	}, maxtime);

	return true;
};

Object.defineProperty(TemasysPlugin, 'interface',
{
	get: function()
	{
		return pluginInterface;
	}
});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"bowser":2,"debug":3,"domready":6,"merge":7}],2:[function(require,module,exports){
/*!
 * Bowser - a browser detector
 * https://github.com/ded/bowser
 * MIT License | (c) Dustin Diaz 2015
 */

!function (name, definition) {
  if (typeof module != 'undefined' && module.exports) module.exports = definition()
  else if (typeof define == 'function' && define.amd) define(definition)
  else this[name] = definition()
}('bowser', function () {
  /**
    * See useragents.js for examples of navigator.userAgent
    */

  var t = true

  function detect(ua) {

    function getFirstMatch(regex) {
      var match = ua.match(regex);
      return (match && match.length > 1 && match[1]) || '';
    }

    function getSecondMatch(regex) {
      var match = ua.match(regex);
      return (match && match.length > 1 && match[2]) || '';
    }

    var iosdevice = getFirstMatch(/(ipod|iphone|ipad)/i).toLowerCase()
      , likeAndroid = /like android/i.test(ua)
      , android = !likeAndroid && /android/i.test(ua)
      , nexusMobile = /nexus\s*[0-6]\s*/i.test(ua)
      , nexusTablet = !nexusMobile && /nexus\s*[0-9]+/i.test(ua)
      , chromeos = /CrOS/.test(ua)
      , silk = /silk/i.test(ua)
      , sailfish = /sailfish/i.test(ua)
      , tizen = /tizen/i.test(ua)
      , webos = /(web|hpw)os/i.test(ua)
      , windowsphone = /windows phone/i.test(ua)
      , windows = !windowsphone && /windows/i.test(ua)
      , mac = !iosdevice && !silk && /macintosh/i.test(ua)
      , linux = !android && !sailfish && !tizen && !webos && /linux/i.test(ua)
      , edgeVersion = getFirstMatch(/edge\/(\d+(\.\d+)?)/i)
      , versionIdentifier = getFirstMatch(/version\/(\d+(\.\d+)?)/i)
      , tablet = /tablet/i.test(ua)
      , mobile = !tablet && /[^-]mobi/i.test(ua)
      , xbox = /xbox/i.test(ua)
      , result

    if (/opera|opr|opios/i.test(ua)) {
      result = {
        name: 'Opera'
      , opera: t
      , version: versionIdentifier || getFirstMatch(/(?:opera|opr|opios)[\s\/](\d+(\.\d+)?)/i)
      }
    }
    else if (/coast/i.test(ua)) {
      result = {
        name: 'Opera Coast'
        , coast: t
        , version: versionIdentifier || getFirstMatch(/(?:coast)[\s\/](\d+(\.\d+)?)/i)
      }
    }
    else if (/yabrowser/i.test(ua)) {
      result = {
        name: 'Yandex Browser'
      , yandexbrowser: t
      , version: versionIdentifier || getFirstMatch(/(?:yabrowser)[\s\/](\d+(\.\d+)?)/i)
      }
    }
    else if (/ucbrowser/i.test(ua)) {
      result = {
          name: 'UC Browser'
        , ucbrowser: t
        , version: getFirstMatch(/(?:ucbrowser)[\s\/](\d+(?:\.\d+)+)/i)
      }
    }
    else if (/mxios/i.test(ua)) {
      result = {
        name: 'Maxthon'
        , maxthon: t
        , version: getFirstMatch(/(?:mxios)[\s\/](\d+(?:\.\d+)+)/i)
      }
    }
    else if (/epiphany/i.test(ua)) {
      result = {
        name: 'Epiphany'
        , epiphany: t
        , version: getFirstMatch(/(?:epiphany)[\s\/](\d+(?:\.\d+)+)/i)
      }
    }
    else if (/puffin/i.test(ua)) {
      result = {
        name: 'Puffin'
        , puffin: t
        , version: getFirstMatch(/(?:puffin)[\s\/](\d+(?:\.\d+)?)/i)
      }
    }
    else if (/sleipnir/i.test(ua)) {
      result = {
        name: 'Sleipnir'
        , sleipnir: t
        , version: getFirstMatch(/(?:sleipnir)[\s\/](\d+(?:\.\d+)+)/i)
      }
    }
    else if (/k-meleon/i.test(ua)) {
      result = {
        name: 'K-Meleon'
        , kMeleon: t
        , version: getFirstMatch(/(?:k-meleon)[\s\/](\d+(?:\.\d+)+)/i)
      }
    }
    else if (windowsphone) {
      result = {
        name: 'Windows Phone'
      , windowsphone: t
      }
      if (edgeVersion) {
        result.msedge = t
        result.version = edgeVersion
      }
      else {
        result.msie = t
        result.version = getFirstMatch(/iemobile\/(\d+(\.\d+)?)/i)
      }
    }
    else if (/msie|trident/i.test(ua)) {
      result = {
        name: 'Internet Explorer'
      , msie: t
      , version: getFirstMatch(/(?:msie |rv:)(\d+(\.\d+)?)/i)
      }
    } else if (chromeos) {
      result = {
        name: 'Chrome'
      , chromeos: t
      , chromeBook: t
      , chrome: t
      , version: getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.\d+)?)/i)
      }
    } else if (/chrome.+? edge/i.test(ua)) {
      result = {
        name: 'Microsoft Edge'
      , msedge: t
      , version: edgeVersion
      }
    }
    else if (/vivaldi/i.test(ua)) {
      result = {
        name: 'Vivaldi'
        , vivaldi: t
        , version: getFirstMatch(/vivaldi\/(\d+(\.\d+)?)/i) || versionIdentifier
      }
    }
    else if (sailfish) {
      result = {
        name: 'Sailfish'
      , sailfish: t
      , version: getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i)
      }
    }
    else if (/seamonkey\//i.test(ua)) {
      result = {
        name: 'SeaMonkey'
      , seamonkey: t
      , version: getFirstMatch(/seamonkey\/(\d+(\.\d+)?)/i)
      }
    }
    else if (/firefox|iceweasel|fxios/i.test(ua)) {
      result = {
        name: 'Firefox'
      , firefox: t
      , version: getFirstMatch(/(?:firefox|iceweasel|fxios)[ \/](\d+(\.\d+)?)/i)
      }
      if (/\((mobile|tablet);[^\)]*rv:[\d\.]+\)/i.test(ua)) {
        result.firefoxos = t
      }
    }
    else if (silk) {
      result =  {
        name: 'Amazon Silk'
      , silk: t
      , version : getFirstMatch(/silk\/(\d+(\.\d+)?)/i)
      }
    }
    else if (/phantom/i.test(ua)) {
      result = {
        name: 'PhantomJS'
      , phantom: t
      , version: getFirstMatch(/phantomjs\/(\d+(\.\d+)?)/i)
      }
    }
    else if (/slimerjs/i.test(ua)) {
      result = {
        name: 'SlimerJS'
        , slimer: t
        , version: getFirstMatch(/slimerjs\/(\d+(\.\d+)?)/i)
      }
    }
    else if (/blackberry|\bbb\d+/i.test(ua) || /rim\stablet/i.test(ua)) {
      result = {
        name: 'BlackBerry'
      , blackberry: t
      , version: versionIdentifier || getFirstMatch(/blackberry[\d]+\/(\d+(\.\d+)?)/i)
      }
    }
    else if (webos) {
      result = {
        name: 'WebOS'
      , webos: t
      , version: versionIdentifier || getFirstMatch(/w(?:eb)?osbrowser\/(\d+(\.\d+)?)/i)
      };
      /touchpad\//i.test(ua) && (result.touchpad = t)
    }
    else if (/bada/i.test(ua)) {
      result = {
        name: 'Bada'
      , bada: t
      , version: getFirstMatch(/dolfin\/(\d+(\.\d+)?)/i)
      };
    }
    else if (tizen) {
      result = {
        name: 'Tizen'
      , tizen: t
      , version: getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.\d+)?)/i) || versionIdentifier
      };
    }
    else if (/qupzilla/i.test(ua)) {
      result = {
        name: 'QupZilla'
        , qupzilla: t
        , version: getFirstMatch(/(?:qupzilla)[\s\/](\d+(?:\.\d+)+)/i) || versionIdentifier
      }
    }
    else if (/chromium/i.test(ua)) {
      result = {
        name: 'Chromium'
        , chromium: t
        , version: getFirstMatch(/(?:chromium)[\s\/](\d+(?:\.\d+)?)/i) || versionIdentifier
      }
    }
    else if (/chrome|crios|crmo/i.test(ua)) {
      result = {
        name: 'Chrome'
        , chrome: t
        , version: getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.\d+)?)/i)
      }
    }
    else if (android) {
      result = {
        name: 'Android'
        , version: versionIdentifier
      }
    }
    else if (/safari|applewebkit/i.test(ua)) {
      result = {
        name: 'Safari'
      , safari: t
      }
      if (versionIdentifier) {
        result.version = versionIdentifier
      }
    }
    else if (iosdevice) {
      result = {
        name : iosdevice == 'iphone' ? 'iPhone' : iosdevice == 'ipad' ? 'iPad' : 'iPod'
      }
      // WTF: version is not part of user agent in web apps
      if (versionIdentifier) {
        result.version = versionIdentifier
      }
    }
    else if(/googlebot/i.test(ua)) {
      result = {
        name: 'Googlebot'
      , googlebot: t
      , version: getFirstMatch(/googlebot\/(\d+(\.\d+))/i) || versionIdentifier
      }
    }
    else {
      result = {
        name: getFirstMatch(/^(.*)\/(.*) /),
        version: getSecondMatch(/^(.*)\/(.*) /)
     };
   }

    // set webkit or gecko flag for browsers based on these engines
    if (!result.msedge && /(apple)?webkit/i.test(ua)) {
      if (/(apple)?webkit\/537\.36/i.test(ua)) {
        result.name = result.name || "Blink"
        result.blink = t
      } else {
        result.name = result.name || "Webkit"
        result.webkit = t
      }
      if (!result.version && versionIdentifier) {
        result.version = versionIdentifier
      }
    } else if (!result.opera && /gecko\//i.test(ua)) {
      result.name = result.name || "Gecko"
      result.gecko = t
      result.version = result.version || getFirstMatch(/gecko\/(\d+(\.\d+)?)/i)
    }

    // set OS flags for platforms that have multiple browsers
    if (!result.msedge && (android || result.silk)) {
      result.android = t
    } else if (iosdevice) {
      result[iosdevice] = t
      result.ios = t
    } else if (mac) {
      result.mac = t
    } else if (xbox) {
      result.xbox = t
    } else if (windows) {
      result.windows = t
    } else if (linux) {
      result.linux = t
    }

    // OS version extraction
    var osVersion = '';
    if (result.windowsphone) {
      osVersion = getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i);
    } else if (iosdevice) {
      osVersion = getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i);
      osVersion = osVersion.replace(/[_\s]/g, '.');
    } else if (android) {
      osVersion = getFirstMatch(/android[ \/-](\d+(\.\d+)*)/i);
    } else if (result.webos) {
      osVersion = getFirstMatch(/(?:web|hpw)os\/(\d+(\.\d+)*)/i);
    } else if (result.blackberry) {
      osVersion = getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i);
    } else if (result.bada) {
      osVersion = getFirstMatch(/bada\/(\d+(\.\d+)*)/i);
    } else if (result.tizen) {
      osVersion = getFirstMatch(/tizen[\/\s](\d+(\.\d+)*)/i);
    }
    if (osVersion) {
      result.osversion = osVersion;
    }

    // device type extraction
    var osMajorVersion = osVersion.split('.')[0];
    if (
         tablet
      || nexusTablet
      || iosdevice == 'ipad'
      || (android && (osMajorVersion == 3 || (osMajorVersion >= 4 && !mobile)))
      || result.silk
    ) {
      result.tablet = t
    } else if (
         mobile
      || iosdevice == 'iphone'
      || iosdevice == 'ipod'
      || android
      || nexusMobile
      || result.blackberry
      || result.webos
      || result.bada
    ) {
      result.mobile = t
    }

    // Graded Browser Support
    // http://developer.yahoo.com/yui/articles/gbs
    if (result.msedge ||
        (result.msie && result.version >= 10) ||
        (result.yandexbrowser && result.version >= 15) ||
		    (result.vivaldi && result.version >= 1.0) ||
        (result.chrome && result.version >= 20) ||
        (result.firefox && result.version >= 20.0) ||
        (result.safari && result.version >= 6) ||
        (result.opera && result.version >= 10.0) ||
        (result.ios && result.osversion && result.osversion.split(".")[0] >= 6) ||
        (result.blackberry && result.version >= 10.1)
        ) {
      result.a = t;
    }
    else if ((result.msie && result.version < 10) ||
        (result.chrome && result.version < 20) ||
        (result.firefox && result.version < 20.0) ||
        (result.safari && result.version < 6) ||
        (result.opera && result.version < 10.0) ||
        (result.ios && result.osversion && result.osversion.split(".")[0] < 6)
        ) {
      result.c = t
    } else result.x = t

    return result
  }

  var bowser = detect(typeof navigator !== 'undefined' ? navigator.userAgent : '')

  bowser.test = function (browserList) {
    for (var i = 0; i < browserList.length; ++i) {
      var browserItem = browserList[i];
      if (typeof browserItem=== 'string') {
        if (browserItem in bowser) {
          return true;
        }
      }
    }
    return false;
  }

  /*
   * Set our detect method to the main bowser object so we can
   * reuse it to test other user agents.
   * This is needed to implement future tests.
   */
  bowser._detect = detect;

  return bowser
});

},{}],3:[function(require,module,exports){

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = require('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // is webkit? http://stackoverflow.com/a/16459606/376773
  return ('WebkitAppearance' in document.documentElement.style) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (window.console && (console.firebug || (console.exception && console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  return JSON.stringify(v);
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs() {
  var args = arguments;
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return args;

  var c = 'color: ' + this.color;
  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
  return args;
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}
  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage(){
  try {
    return window.localStorage;
  } catch (e) {}
}

},{"./debug":4}],4:[function(require,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = debug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = require('ms');

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lowercased letter, i.e. "n".
 */

exports.formatters = {};

/**
 * Previously assigned color.
 */

var prevColor = 0;

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 *
 * @return {Number}
 * @api private
 */

function selectColor() {
  return exports.colors[prevColor++ % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function debug(namespace) {

  // define the `disabled` version
  function disabled() {
  }
  disabled.enabled = false;

  // define the `enabled` version
  function enabled() {

    var self = enabled;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // add the `color` if not set
    if (null == self.useColors) self.useColors = exports.useColors();
    if (null == self.color && self.useColors) self.color = selectColor();

    var args = Array.prototype.slice.call(arguments);

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %o
      args = ['%o'].concat(args);
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    if ('function' === typeof exports.formatArgs) {
      args = exports.formatArgs.apply(self, args);
    }
    var logFn = enabled.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }
  enabled.enabled = true;

  var fn = exports.enabled(namespace) ? enabled : disabled;

  fn.namespace = namespace;

  return fn;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  var split = (namespaces || '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

},{"ms":5}],5:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} options
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options){
  options = options || {};
  if ('string' == typeof val) return parse(val);
  return options.long
    ? long(val)
    : short(val);
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = '' + str;
  if (str.length > 10000) return;
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
  if (!match) return;
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function short(ms) {
  if (ms >= d) return Math.round(ms / d) + 'd';
  if (ms >= h) return Math.round(ms / h) + 'h';
  if (ms >= m) return Math.round(ms / m) + 'm';
  if (ms >= s) return Math.round(ms / s) + 's';
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function long(ms) {
  return plural(ms, d, 'day')
    || plural(ms, h, 'hour')
    || plural(ms, m, 'minute')
    || plural(ms, s, 'second')
    || ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) return;
  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
  return Math.ceil(ms / n) + ' ' + name + 's';
}

},{}],6:[function(require,module,exports){
/*!
  * domready (c) Dustin Diaz 2014 - License MIT
  */
!function (name, definition) {

  if (typeof module != 'undefined') module.exports = definition()
  else if (typeof define == 'function' && typeof define.amd == 'object') define(definition)
  else this[name] = definition()

}('domready', function () {

  var fns = [], listener
    , doc = document
    , hack = doc.documentElement.doScroll
    , domContentLoaded = 'DOMContentLoaded'
    , loaded = (hack ? /^loaded|^c/ : /^loaded|^i|^c/).test(doc.readyState)


  if (!loaded)
  doc.addEventListener(domContentLoaded, listener = function () {
    doc.removeEventListener(domContentLoaded, listener)
    loaded = 1
    while (listener = fns.shift()) listener()
  })

  return function (fn) {
    loaded ? setTimeout(fn, 0) : fns.push(fn)
  }

});

},{}],7:[function(require,module,exports){
/*!
 * @name JavaScript/NodeJS Merge v1.2.0
 * @author yeikos
 * @repository https://github.com/yeikos/js.merge

 * Copyright 2014 yeikos - MIT license
 * https://raw.github.com/yeikos/js.merge/master/LICENSE
 */

;(function(isNode) {

	/**
	 * Merge one or more objects 
	 * @param bool? clone
	 * @param mixed,... arguments
	 * @return object
	 */

	var Public = function(clone) {

		return merge(clone === true, false, arguments);

	}, publicName = 'merge';

	/**
	 * Merge two or more objects recursively 
	 * @param bool? clone
	 * @param mixed,... arguments
	 * @return object
	 */

	Public.recursive = function(clone) {

		return merge(clone === true, true, arguments);

	};

	/**
	 * Clone the input removing any reference
	 * @param mixed input
	 * @return mixed
	 */

	Public.clone = function(input) {

		var output = input,
			type = typeOf(input),
			index, size;

		if (type === 'array') {

			output = [];
			size = input.length;

			for (index=0;index<size;++index)

				output[index] = Public.clone(input[index]);

		} else if (type === 'object') {

			output = {};

			for (index in input)

				output[index] = Public.clone(input[index]);

		}

		return output;

	};

	/**
	 * Merge two objects recursively
	 * @param mixed input
	 * @param mixed extend
	 * @return mixed
	 */

	function merge_recursive(base, extend) {

		if (typeOf(base) !== 'object')

			return extend;

		for (var key in extend) {

			if (typeOf(base[key]) === 'object' && typeOf(extend[key]) === 'object') {

				base[key] = merge_recursive(base[key], extend[key]);

			} else {

				base[key] = extend[key];

			}

		}

		return base;

	}

	/**
	 * Merge two or more objects
	 * @param bool clone
	 * @param bool recursive
	 * @param array argv
	 * @return object
	 */

	function merge(clone, recursive, argv) {

		var result = argv[0],
			size = argv.length;

		if (clone || typeOf(result) !== 'object')

			result = {};

		for (var index=0;index<size;++index) {

			var item = argv[index],

				type = typeOf(item);

			if (type !== 'object') continue;

			for (var key in item) {

				var sitem = clone ? Public.clone(item[key]) : item[key];

				if (recursive) {

					result[key] = merge_recursive(result[key], sitem);

				} else {

					result[key] = sitem;

				}

			}

		}

		return result;

	}

	/**
	 * Get type of variable
	 * @param mixed input
	 * @return string
	 *
	 * @see http://jsperf.com/typeofvar
	 */

	function typeOf(input) {

		return ({}).toString.call(input).slice(8, -1).toLowerCase();

	}

	if (isNode) {

		module.exports = Public;

	} else {

		window[publicName] = Public;

	}

})(typeof module === 'object' && module && typeof module.exports === 'object' && module.exports);
},{}]},{},[1])(1)
});